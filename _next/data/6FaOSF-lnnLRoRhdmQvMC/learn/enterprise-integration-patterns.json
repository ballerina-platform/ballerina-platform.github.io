{"pageProps":{"categories":["Messaging Systems","Messaging Channels","Message Construction","Message Routing","Message Transformation","Messaging Endpoints","System Management"],"patterns":{"Message Routing":[{"name":"Content-Based Router","tagline":"Route messages based on message content","desc":"Content-based router routes each message to the correct recipient based on message content.","helps":"Ballerina supports conditional logic with if-else and match statements. This can be used to route messages based on message content, header, or any custom logic. Ballerina type system supports union types (e.g., `Country` enum below is a union), which helps to define choices in a type-safe and readable manner.","category":"Message Routing","index":24,"tags":["Content Based Router","Message Filter","Dynamtic Router"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/ContentBasedRouter.html"},{"tagline":"Filter uninterested messages","desc":"Message filter neglects the uninterested messages based on criteria and publishes the filtered message to another channel.","category":"Message Routing","index":25,"helps":"Ballerina enables filtering messages using basic control structures such as if and switch statements.","tags":["Message Filter","Message Channel","Message Endpoint"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/Filter.html","name":"Message Filter"},{"tagline":"Process messages with multiple elements","desc":"Splitter splits the message into multiple messages, each containing one of the elements.","helps":"Ballerina supports arrays and maps as first-class data structures. These structures can be iterated over using `foreach` and query expressions.","category":"Message Routing","index":28,"tags":["Splitter","Content Filter","Event Message"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/Sequencer.html","name":"Splitter"},{"tagline":"Wait for a sequence of messages and combine them","desc":"Aggregator patiently collects a sequence of messages and combines them once all have been received.","category":"Message Routing","index":29,"helps":"Ballerina provides convenient map and table data structures for temporary message storage. Ballerina provides robust support for distributed storage with the Redis package. Additionally, it offers seamless integration with various SQL and NoSQL databases for persistent data storage. Ballerina's cache package is an efficient in-memory cache solution that includes automatic cleanup mechanisms.","tags":["Aggregator"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/Aggregator.html","name":"Aggregator"},{"name":"Scatter-Gather","tagline":"Send messages to multiple recipients and re-aggregate the responses","desc":"Scatter-gather broadcasts a message to multiple recipients and re-aggregates the responses back into a single message.","category":"Message Routing","index":32,"helps":"Ballerina has a lightweight [concurrency](/learn/by-example/named-workers/) model with built-in syntax support. This helps to send messages parallelly and to wait on aggregation. Query expressions are convenient for transforming, ordering, and filtering the aggregated data.","tags":["Scatter-Gather","Aggregator","Message Channel","Message Endpoint","Message Router","Message"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/BroadcastAggregate.html"},{"tagline":"Route message according to an order.","desc":"Route the message to the next component according to the sequence of processing steps specified in a routing slip.","category":"Message Routing","index":33,"helps":"Ballerina excels in enabling seamless integration of diverse services with inherent concurrent support, as well as in data binding, type enforcement, and native error-handling capabilities.","tags":["Routing Slip","Message Channel","Message Endpoint","Message Router"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/RoutingTable.html","name":"Routing Slip"},{"tagline":"Process messages with steps unknown at design time","desc":"Process manager orchestrates a sequence of steps that are not known at design time.","helps":"Ballerina provides control flow constructs such as `if`-`else` and `match` statements to implement complex process flows.","category":"Message Routing","index":34,"tags":["Process Manager","Command Message","Aggregator","Point-to-Point Channel"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/ProcessManager.html","name":"Process Manager"}],"Message Transformation":[{"tagline":"Add data to message","desc":"Content enricher adds data that was not sent by the original sender to the message.","category":"Message Transformation","index":37,"helps":"Ballerina enables additional lookups to enrich the message, such as database lookups, REST API calls, etc. Spread operator (...) helps to create new records out of existing records while enriching them with additional data.","tags":["Content Enricher","Message Channel","Message Endpoint","Message"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/DataEnricher.html","name":"Content Enricher"},{"tagline":"Remove data from message","desc":"The content filter removes data from the original message and can also be employed to simplify the message structure.","category":"Message Transformation","index":38,"helps":"Ballerina excels at manipulating data and handling diverse formats, structures, and transformations. The [query expression](/learn/by-example/query-expressions/) (`from` keyword) is useful for transforming messages. The `select` clause, as shown below, can be used to create new records from existing ones while refining data. The `where` clause can be used to filter items from an array.","tags":["Content Filter","Message Channel","Message Endpoint"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/ContentFilter.html","name":"Content Filter"},{"tagline":"Process messages with different formats","desc":"Normalizer routes each message type through a custom message translator so that the resulting messages match a common format.","category":"Message Transformation","index":40,"helps":"Ballerina's type test (`is` keyword) and match statement can both be used to test the structure of incoming data. Then the data can be transformed into the required format to construct new data structures. Ballerina's data-oriented design helps with complex transformations with features such as destructuring, query expressions, spread operator, etc.","tags":["Normalizer","Message Channel","Message Endpoint","Message Translator","Message Router","Message"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/Normalizer.html","name":"Normalizer"}],"Message Construction":[{"tagline":"Transfer data to another application","desc":"The document message transfers data from one application to another. The focus is on the data and reliability, not on the timing of the transfer.","category":"Message Construction","index":16,"helps":"Ballerina supports sending and receiving data in multiple formats such as JSON and XML over different protocols such as HTTP, GRPC, Kafka, etc. Depending on the protocol, Ballerina provides different reliability mechanisms. As an example, the Ballerina HTTP client supports retries, load balancing, and circuit breaking.","tags":["Document Message","Message Channel","Message Endpoint","Point-to-Point Channel","Request-Reply"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/DocumentMessage.html","name":"Document Message"},{"tagline":"Notify other applications about something that happened","helps":"Ballerina packages such as http, kafka, websocket, etc., in the Ballerina library provide listeners, through which you can consume events from other applications. Each such package provides protocol-specific message sending APIs as well.","desc":"Event message notifies other applications about something that happened. Unlike document message, the focus is on the timing of the message rather than the content.","category":"Message Construction","index":17,"tags":["Event Message","Command Message","Point-to-Point Channel"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/EventMessage.html","name":"Event Message"},{"tagline":"Send large data sets in chunks","desc":"Message sequence sends the data as a sequence of messages and marks each message with sequence identification fields.","category":"Message Construction","index":21,"helps":"Ballerina supports loop constructs such as `while`, `foreach`, and `map`. These constructs can be used to iterate over data and send it in chunks. Program state can be kept in variables.","tags":["Message Sequence","Message Channel","Message Endpoint","Message"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageSequence.html","name":"Message Sequence"},{"tagline":"Process the data based on received message format","desc":"The Format Indicator will identify the message format based on the version or structure and process it.","category":"Message Construction","index":23,"helps":"The `is` keyword in Ballerina distinguishes between structured types, aiding in distinguishing various message versions.","tags":["Format Indicator","Cannonical Data Model"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/FormatIndicator.html","name":"Format Indicator"}],"Messaging Endpoints":[{"tagline":"Mapping infrastructure messages to domain objects","desc":"The Messaging Mapper maps infrastructure messages to domain objects.","category":"Messaging Endpoints","index":43,"helps":"Ballerina services facilitate the direct mapping of incoming and outgoing domain objects to JSON values. Ballerina's table data structure offers the ability to store domain objects in memory, closely resembling the functionality of SQL-based tables.","tags":["Messaging Mapper","Message Translator"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessagingMapper.html","name":"Messaging Mapper"},{"tagline":"Consume messages when the application is ready","desc":"Polling consumer consumes messages from a channel when the application is ready to process them.","helps":"Ballerina's concurrency model enables writing simple procedural code that is nevertheless executed in a non-blocking manner. In the below example, `sleep` does not block the underlying thread. Other Ballerina concurrency constructs, such as `wait`, behave similarly.","category":"Messaging Endpoints","index":45,"tags":["Polling Consumer","Durable Subscriber","Message"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/PollingConsumer.html","name":"Polling Consumer"},{"tagline":"Coordinate message processing","desc":"Message dispatcher coordinates message processing among multiple performers.","helps":"Ballerina programs can maintain the state internally using variables and perform logic based on the state.","category":"Messaging Endpoints","index":48,"tags":["Message Dispatcher","Competing Consumers","Transactional Client"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageDispatcher.html","name":"Message Dispatcher"}],"System Management":[{"tagline":"Publish to a secondary channel for inspection","desc":"Wire tap publishes each incoming message unmodified to a secondary channel for inspection and analysis.","category":"System Management","index":55,"helps":"Ballerina has a lightweight concurrency model with built-in syntax support. This helps to send messages to a secondary channel parallelly without blocking the main channel.","tags":["Wire Tap","Message Channel","Message Endpoint"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/WireTap.html","name":"Wire Tap"},{"tagline":"Analyze and debug message flow in a loosely coupled system","desc":"Message history maintains a list of all components that the message passed through. Every component that processes the message adds one entry to the list.","helps":"Depending on the protocol, Ballerina provides APIs to manipulate message content, including headers.","index":56,"category":"System Management","tags":["Message History","Message Store","Message Router"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageHistory.html","name":"Message History"},{"tagline":"Capture message information in a central location","desc":"Message store captures information about each message in a central location.","category":"System Management","index":57,"helps":"Ballerina can send messages to multiple channels during a single service invocation. Ballerina's concurrency model helps to send messages asynchronously without blocking the main channel. The wildcard binding pattern is used to indicate a 'fire-and-forget' invocation, where the response is not used.","tags":["Message Store","Message Channel","Wire Tap","Message Endpoint","Message"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageStore.html","name":"Message Store"},{"tagline":"Assure health of messaging components","desc":"Assure the health of messaging components by sending test messages. Note: Instead of the original pattern, we have selected a modern version where infrastructure polls for the health of the components.","helps":"Ballerina provides built-in support for creating, propagating(`check` keyword), and handling errors. Error handling logic can be performed after testing if a given value is an error using the `is` keyword.","category":"System Management","index":59,"tags":["Test Message","Message Filter","Message"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/TestMessage.html","name":"Test Message"}],"Messaging Systems":[{"tagline":"Route messages to different output channels","desc":"Message router consumes a message from one channel and republishes it to a different channel depending on a set of conditions.","category":"Messaging Systems","index":3,"helps":"Ballerina supports conditional logic with if-else and match statements. This can be used to route messages based on message content, header, or any custom logic. Ballerina type system supports union types (e.g. `Country` enum below is a union) which helps to define choices in a type-safe and readable manner.","tags":["Message Router","Message Channel","Message Endpoint","Message"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageRouter.html","name":"Message Router"},{"tagline":"Transform one message format to another","desc":"The Message Translator transforms messages from one structure to another.","category":"Messaging Systems","index":4,"helps":"Ballerina comes with a data mapper as part of its Visual Studio Code extension, allowing you to effortlessly map data from one record to another. Ballerina query expression syntax enables you to filter, order, and aggregate values to craft custom message values. Ballerina provides convenient tools like `JSON as Record` and `XML as Record`, which automatically generate Ballerina records based on sample JSON or XML input values.","tags":["Message Translator","Message Endpoint"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageTranslator.html","name":"Message Translator"}],"Messaging Channels":[{"tagline":"Connect messaging systems","desc":"Massaging bridge connects multiple messaging systems by mapping channels and transforming message formats.","category":"Messaging Channels","index":13,"helps":"Single Ballerina program can connect to multiple messaging systems. Each system may utilize different protocols and message formats. Protocols such as HTTP, GRPC, Kafka, JDBC, etc. are supported via Ballerina's rich set of stranded libraries. JSON and XML are supported at the type system level. Other formats such as CSV and EDI are supported via libraries.","tags":["Messaging Bridge","Message Channel","Message Endpoint","Channel Adapter","Message"],"link":"https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessagingBridge.html","name":"Messaging Bridge"}]}},"__N_SSG":true}